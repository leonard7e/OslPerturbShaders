/*
  Eine Bastelei â€¦
*/

#define EPSILON 0.001

int matchCoord(point q)
{
  point r = q + point(pow(2.0,22));

  if (fmod(r[0]+r[1]+r[2],2) < EPSILON) {
   return 1;
  }
  // if (fmod(r[0],2)+fmod(r[1],2)+fmod(r[2],2) < EPSILON) {
  //  return 1;
  // }
  else {
   return 0;
  }
}

void next_coords (point pCoord, output float dst, output point neighbour) {
  point on_raster = floor(pCoord);

  dst = pow(2.0,22);
  neighbour = point(0);

  for (int dx = 0; dx <= 1; ++dx) {
    for (int dy = 0; dy <= 1; ++dy) {
      for (int dz = 0; dz <= 1; ++dz) {
        point q = on_raster + vector((float)dx,(float)dy,(float)dz);

        if (matchCoord(q)) {
          float d = distance(q,pCoord);
          if(d < dst) {
            dst = d;
            neighbour= q;
          }
        }
      }
    }
  }
}

shader cpattern
        [[ string as_node_name = "Pattern Shader"
        ,  string as_classification = "utility" ]]
(
        point in_Coords = P
        [[ string label = "Coordinates" ]],

        output color out_C = 0,
        output float out_F = 0
)
{
  // point next_sorted [NMAX]= {point(0)};
	// float next_dst [NMAX] = {0.0};

  float dst;
  point neighbour;
  next_coords (in_Coords, dst, neighbour);
	out_F = dst;
  out_C = neighbour;
}
