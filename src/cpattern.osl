/*
  Eine Bastelei …
*/

#include "math.h"

#define EPSILON 0.001

/*
Durch Variation von matchCoord können wir verschiedene Muster erzeugen.

int matchCoord(point q)
{
  point r = q + point(pow(2.0,22));

  if (fmod(r[0]+r[1]+r[2],2) < EPSILON) {
   return 1;
  }
  else {
   return 0;
  }
}

int matchCoord(point q)
{
  point r = q + point(pow(2.0,22));

  if (fmod(r[0]+r[1]+r[2],4) < EPSILON) {
   return 1;
  }
  if (fmod(r[0],2)+fmod(r[1],2)+fmod(r[2],2) < EPSILON) {
   return 1;
  }
  else {
   return 0;
  }
}

int matchCoord(point q)
{
  point r = q + point(pow(2.0,22));

  if (fmod(r[0]-r[1]+r[2],2) + fmod(r[1]-r[0]+r[2],3)< EPSILON) {
   return 1;
  }
  if (fmod(r[0]+r[1]+r[2],5) < EPSILON) {
   return 1;
  }
  else {
   return 0;
  }
}

int matchCoord(point q)
{
  point r = q + point(pow(2.0,22));

  // if (fmod(r[0]+r[1]+r[2],2) < EPSILON) {
  //  return 1;
  // }
  if (fmod(r[0],2)+fmod(r[1],2) - fmod(r[0]+r[1],2) < EPSILON) {
   return 1;
  }
  else {
   return 0;
  }
}

int matchCoord(point q)
{
point r = q + point(pow(2.0,22));

if (sin(r[0]*M_PI/2) + cos(r[1]*M_PI/4) < EPSILON) {
return 1;
}

return 0;
}


int matchCoord(point q)
{
  point r = q + point(pow(2.0,22));

  if ( fmod(r[0]+r[1], 4) < EPSILON) {
    return 0;
  }
  if ( fmod(r[0]+r[1], 2) < EPSILON) {
    return 1;
  }

  return 0;
}
*/


// matchCoord basing on array?
int matchCoord(point q)
{
  point r = q + point(pow(2.0,22));

  if ( fmod(r[0]+r[1], 2) < EPSILON) {
    return 1;
  }

  return 0;
}

#define LOWER -1
#define UPPER 1

void next_coords (point pCoord, output float dst, output point neighbour) {
  point on_raster = floor(pCoord);

  dst = pow(2.0,22);
  neighbour = point(0);

  for (int dx = LOWER; dx <= UPPER; ++dx) {
    for (int dy = LOWER; dy <= UPPER; ++dy) {
      for (int dz = LOWER; dz <= UPPER; ++dz) {
        point q = on_raster + vector((float)dx,(float)dy,(float)dz);

        if (matchCoord(q)) {
          float d = distance(q,pCoord);
          if(d < dst) {
            dst = d;
            neighbour= q;
          }
        }
      }
    }
  }
}

shader cpattern
        [[ string as_node_name = "Pattern Shader"
        ,  string as_classification = "utility" ]]
(
        point in_Coords = P
        [[ string label = "Coordinates" ]],

        output color out_C = 0,
        output float out_F = 0
)
{
  // point next_sorted [NMAX]= {point(0)};
	// float next_dst [NMAX] = {0.0};

  float dst;
  point neighbour;
  next_coords (in_Coords, dst, neighbour);
  out_F = dst;
  out_C = cellnoise(neighbour);
  // out_F = 1-sigmoid(out_F);
}
