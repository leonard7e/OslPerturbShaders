/*
  Eine Bastelei â€¦
*/

int matchCoord(point q)
{
  if (fmod(q[0],2)+ fmod(q[1],2) +fmod(q[2],2) < 0.01) {
   return 1;
  }
  else {
   return 0;
  }
}

void next_coords (point pCoord, output float dst, output point neighbour) {
  point on_raster = floor(pCoord);

  dst = pow(2.0,22);
  neighbour = point(0);

  for (int dx = -1; dx <= 1; ++dx) {
    for (int dy = -1; dy <= 1; ++dy) {
      for (int dz = -1; dz <= 1; ++dz) {
        point q = on_raster + vector((float)dx,(float)dy,(float)dz);

        if (matchCoord(q)) {
          float d = distance(q,pCoord);
          if(d < dst) {
            dst = d;
            neighbour= q;
          }
        }
      }
    }
  }
}

shader cpattern
        [[ string as_node_name = "Pattern Shader"
        ,  string as_classification = "utility" ]]
(
        point in_Coords = P
        [[ string label = "Coordinates" ]],

        output color out_C = 0,
        output float out_F = 0
)
{
  // point next_sorted [NMAX]= {point(0)};
	// float next_dst [NMAX] = {0.0};

  float dst;
  point neighbour;
  next_coords (in_Coords, dst, neighbour);
	out_F = dst;
  out_C = neighbour;
}
